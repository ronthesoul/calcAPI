name: calcAPI-ci.yaml

on:
  push:
    branches: [ "main" ]
    paths:
      - '**/*.go'
      - go.mod
      - go.sum
      - '.github/workflows/**'
  pull_request:
    branches: [ "main" ]
    paths:
      - '**/*.go'
      - go.mod
      - go.sum
      - '.github/workflows/**'

jobs:
  build:
    runs-on: ubuntu-latest
    env:
      SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
      NOTIFY: .github/workflows/notify.sh
      IMAGE: m4gapower/calcapi   
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24.6'
          cache: true

      - name: Notify Start
        shell: bash
        run: |
          chmod +x "$NOTIFY"
          echo v1.63.4 > .golangci.version
          mkdir -p artifacts
          if [ -n "$SLACK_WEBHOOK" ]; then
            "$NOTIFY" ":bell: Starting ${{ github.event.repository.name }} CI - Run (#$GITHUB_RUN_NUMBER) Commit: ${{ github.event.head_commit.message }} :bell:" "$SLACK_WEBHOOK"
          else
            echo "SLACK_WEBHOOK not set; skipping Slack notify."
          fi

      - name: Cache golangci-lint binary
        id: lintcache
        uses: actions/cache@v4
        with:
          path: ~/go/bin/golangci-lint
          key: ${{ runner.os }}-golangci-${{ hashFiles('.golangci.version') }}

      - name: Install dependencies
        shell: bash
        run: |
          sudo apt-get update -y && sudo apt-get install -y jq
          go mod tidy
          go mod download
          if [ "${{ steps.lintcache.outputs.cache-hit }}" != "true" ]; then
            GOLANGCI_VERSION=$(cat .golangci.version || echo v1.63.4)
            go install github.com/golangci/golangci-lint/cmd/golangci-lint@${GOLANGCI_VERSION}
          fi

      - name: Run golangci-lint
        shell: bash
        run: |
          set +e
          [ -n "$SLACK_WEBHOOK" ] && "$NOTIFY" "Starting Step - Lint" "$SLACK_WEBHOOK" || true
          mkdir -p artifacts
          golangci-lint run 2>&1 | tee artifacts/lint.log
          STATUS=${PIPESTATUS[0]}
          OUTPUT=$(sed 's/"/\\"/g' artifacts/lint.log | sed ':a;N;$!ba;s/\n/\\n/g')
          if [ $STATUS -eq 0 ]; then
            [ -n "$SLACK_WEBHOOK" ] && "$NOTIFY" "Step - Lint ‚úÖ Success" "$SLACK_WEBHOOK" || true
          else
            [ -n "$SLACK_WEBHOOK" ] && "$NOTIFY" "Step - Lint ‚ùå Failed:\n\`\`\`$OUTPUT\`\`\`" "$SLACK_WEBHOOK" || true
            exit 1
          fi

      - name: Early Build
        shell: bash
        run: |
          set +e
          [ -n "$SLACK_WEBHOOK" ] && "$NOTIFY" "Starting Step - Early Build" "$SLACK_WEBHOOK" || true
          mkdir -p artifacts
          go build -v ./... 2>&1 | tee artifacts/build.log
          STATUS=${PIPESTATUS[0]}
          OUTPUT=$(cat artifacts/build.log)
          if [ $STATUS -eq 0 ]; then
            [ -n "$SLACK_WEBHOOK" ] && "$NOTIFY" "Step - Early Build ‚úÖ Success" "$SLACK_WEBHOOK" || true
          else
            [ -n "$SLACK_WEBHOOK" ] && "$NOTIFY" "Step - Early Build ‚ùå Failed\n\`\`\`$OUTPUT\`\`\`" "$SLACK_WEBHOOK" || true
            exit 1
          fi

      - name: Test
        shell: bash
        run: |
          set +e
          [ -n "$SLACK_WEBHOOK" ] && "$NOTIFY" "Starting Step - Test" "$SLACK_WEBHOOK" || true
          mkdir -p artifacts
          go test -v ./... 2>&1 | tee artifacts/test.log
          STATUS=${PIPESTATUS[0]}
          OUTPUT=$(sed 's/"/\\"/g' artifacts/test.log | sed ':a;N;$!ba;s/\n/\\n/g')
          if [ $STATUS -eq 0 ]; then
            [ -n "$SLACK_WEBHOOK" ] && "$NOTIFY" "Step - Test ‚úÖ Success" "$SLACK_WEBHOOK" || true
          else
            [ -n "$SLACK_WEBHOOK" ] && "$NOTIFY" "Step - Test ‚ùå Failed:\n\`\`\`$OUTPUT\`\`\`" "$SLACK_WEBHOOK" || true
            exit 1
          fi

      - name: Build Docker image
        shell: bash
        run: |
          set -o pipefail
          [ -n "$SLACK_WEBHOOK" ] && "$NOTIFY" "üê≥ Starting Step - Build Docker image" "$SLACK_WEBHOOK" || true
          mkdir -p artifacts
          docker build --progress=plain -t "$IMAGE:latest" . 2>&1 | tee artifacts/docker-build.log
          STATUS=${PIPESTATUS[0]}
          if [ $STATUS -eq 0 ]; then
            [ -n "$SLACK_WEBHOOK" ] && "$NOTIFY" "Step - Build Docker image ‚úÖ Success" "$SLACK_WEBHOOK" || true
          else
            [ -n "$SLACK_WEBHOOK" ] && "$NOTIFY" "Step - Build Docker image ‚ùå Failed" "$SLACK_WEBHOOK" || true
            exit 1
          fi

      - name: Run & Test container
        shell: bash
        run: |
          [ -n "$SLACK_WEBHOOK" ] && "$NOTIFY" "üß™ Starting Step - Run & Test container" "$SLACK_WEBHOOK" || true
          docker run -d --rm -p 8080:8080 --name mycalc_test "$IMAGE:latest"
          mkdir -p artifacts
          # Try for up to ~10s
          for i in {1..10}; do
            if curl -fsS --max-time 2 http://localhost:8080/health | jq -e -r '.status=="ok"' >/dev/null; then
              HEALTH_JSON=$(curl -fsS http://localhost:8080/health || echo '{}')
              echo "$HEALTH_JSON" > artifacts/health.json
              SHORT=$(echo "$HEALTH_JSON" | jq -c .)
              [ -n "$SLACK_WEBHOOK" ] && "$NOTIFY" "Step - Run & Test container ‚úÖ Success (on :8080)\nHealth: \`\`\`${SHORT}\`\`\`" "$SLACK_WEBHOOK" || true
              docker stop mycalc_test
              exit 0
            fi
            sleep 1
          done
          # failure path: capture logs
          curl -fsS http://localhost:8080/health > artifacts/health.json || true
          docker logs mycalc_test > artifacts/container.log 2>&1 || true
          TAIL=$(tail -n 80 artifacts/container.log | sed 's/"/\\"/g' | sed ':a;N;$!ba;s/\n/\\n/g')
          [ -n "$SLACK_WEBHOOK" ] && "$NOTIFY" "Step - Run & Test container ‚ùå Failed (no healthy response)\nLast logs:\n\`\`\`${TAIL}\`\`\`" "$SLACK_WEBHOOK" || true
          docker stop mycalc_test || true
          exit 1

      - name: Compute next SemVer MINOR tag
        shell: bash
        run: |
          [ -n "$SLACK_WEBHOOK" ] && "$NOTIFY" "üî¢ Starting Step - Compute next SemVer MINOR tag" "$SLACK_WEBHOOK" || true
          LATEST_SEMVER=$(
            curl -s "https://hub.docker.com/v2/repositories/$IMAGE/tags/?page_size=100" |
            jq -r '[.results[].name | select(test("^[0-9]+\\.[0-9]+\\.[0-9]+$"))]
                    | sort_by(split(".")|map(tonumber)) | last // empty'
          )
          BASE=${LATEST_SEMVER:-1.0.0}
          IFS='.' read -r MAJOR MINOR PATCH <<< "$BASE"
          NEW_TAG="${MAJOR}.$((MINOR+1)).0"
          echo "new_tag=$NEW_TAG" >> "$GITHUB_ENV"
          [ -n "$SLACK_WEBHOOK" ] && "$NOTIFY" "Step - Compute tag ‚úÖ $BASE ‚Üí $NEW_TAG" "$SLACK_WEBHOOK" || true

      - name: Tag image with NEW_TAG
        shell: bash
        run: |
          [ -n "$SLACK_WEBHOOK" ] && "$NOTIFY" "üè∑Ô∏è Starting Step - Tag image as ${IMAGE}:${new_tag}" "$SLACK_WEBHOOK" || true
          docker tag "$IMAGE:latest" "$IMAGE:${new_tag}"
          [ -n "$SLACK_WEBHOOK" ] && "$NOTIFY" "Step - Tag image ‚úÖ ${IMAGE}:${new_tag}" "$SLACK_WEBHOOK" || true

      - name: Push image(s)
        shell: bash
        run: |
          [ -n "$SLACK_WEBHOOK" ] && "$NOTIFY" "üì§ Starting Step - Push image(s)" "$SLACK_WEBHOOK" || true
          echo "${{ secrets.DOCKERHUB_TOKEN }}" | docker login -u "${{ secrets.DOCKERHUB_USERNAME }}" --password-stdin
          docker push "$IMAGE:latest"
          docker push "$IMAGE:${new_tag}"
          [ -n "$SLACK_WEBHOOK" ] && "$NOTIFY" "Step - Push image(s) ‚úÖ $IMAGE:latest & $IMAGE:${new_tag}" "$SLACK_WEBHOOK" || true

      - name: Show changed files (logs) + notify
        shell: bash
        run: |
          COMPARE="https://github.com/${{ github.repository }}/compare/${{ github.event.before }}...${{ github.sha }}"
          CHANGES="$(git diff --name-status ${{ github.event.before }} ${{ github.sha }})"
          echo "Compare: $COMPARE"
          echo "$CHANGES"
          MSG=$'Changes in this push:\n'"$COMPARE"$'\n\n'"$CHANGES"
          [ -n "$SLACK_WEBHOOK" ] && "$NOTIFY" "$MSG" "$SLACK_WEBHOOK" || true

      - name: Final pipeline result
        if: success()
        shell: bash
        run: |
          [ -n "$SLACK_WEBHOOK" ] && "$NOTIFY" "üöÄ Pipeline completed successfully!" "$SLACK_WEBHOOK" || true

      - name: Save CI logs for autofix
        if: failure()
        uses: actions/cache/save@v4
        with:
          path: artifacts
          key: ci-logs-${{ github.run_id }}

      - name: Final pipeline failure
        if: failure()
        shell: bash
        run: |
          [ -n "$SLACK_WEBHOOK" ] && "$NOTIFY" "üî• Pipeline failed!" "$SLACK_WEBHOOK" || true

  autofix:
    needs: build
    if: ${{ needs.build.result == 'failure' && (github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.pull_request.head.repo.full_name == github.repository)) }}
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    env:
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      OPENAI_MODEL: ${{ vars.OPENAI_MODEL || 'gpt-4.1-mini' }}
    steps:
      - name: Check out source
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Restore CI logs
        uses: actions/cache/restore@v4
        with:
          path: artifacts
          key: ci-logs-${{ github.run_id }}
          fail-on-cache-miss: true

      - name: Prepare prompt
        shell: bash
        run: |
          echo "Preparing prompt from logs..."
          {
            echo "You are an expert Go developer and CI engineer."
            echo "Task: Read the attached CI logs (lint/test/build/docker) and return a SINGLE unified diff patch that fixes the issues with minimal changes."
            echo "Constraints:"
            echo " - Only change files in this repo."
            echo " - Keep code style consistent."
            echo " - If a handler is wrong (e.g., /divide mapped to Add), fix it."
            echo " - Flush zap logger properly (use _ = zl.Sync() in defer)."
            echo " - For health check, ensure /health returns {\"status\":\"ok\"}."
            echo "Output format: put ONLY the patch inside a fenced code block like:"
            echo '```diff'
            echo '--- a/path/to/file'
            echo '+++ b/path/to/file'
            echo '@@ ...'
            echo '```'
            echo
            echo "=== LINT ==="
            cat artifacts/lint.log 2>/dev/null || true
            echo
            echo "=== BUILD ==="
            cat artifacts/build.log 2>/dev/null || true
            echo
            echo "=== TEST ==="
            cat artifacts/test.log 2>/dev/null || true
            echo
            echo "=== DOCKER BUILD ==="
            cat artifacts/docker-build.log 2>/dev/null || true
            echo
            echo "=== HEALTH ==="
            sed -e 's/^/HEALTH: /' artifacts/health.json 2>/dev/null || true
          } > prompt.txt
          wc -c prompt.txt || true

      - name: Call OpenAI for patch
        shell: bash
        env:
          LANG: C.UTF-8
        run: |
          if [ -z "$OPENAI_API_KEY" ]; then
            echo "OPENAI_API_KEY not set; skipping autofix."; exit 0
          fi
          BODY=$(jq -Rs --arg model "$OPENAI_MODEL" '{model:$model, input:[{"role":"user","content":.}]}' < prompt.txt)
          RESP=$(curl -sS https://api.openai.com/v1/responses \
            -H "Authorization: Bearer ${OPENAI_API_KEY}" \
            -H "Content-Type: application/json" \
            -d "$BODY")
          echo "$RESP" > openai_response.json
          TEXT=$(jq -r '.output_text // ""' openai_response.json)
          if [ -z "$TEXT" ] || [ "$TEXT" = "null" ]; then
            TEXT=$(jq -r '[.output[]?.content[]?.text[]? // empty] | join("")' openai_response.json)
          fi
          printf "%s\n" "$TEXT" > openai_text.txt
          awk '
            /^```(diff|patch)/ {inblock=1; next}
            /^```/ && inblock==1 {inblock=0; next}
            inblock==1 {print}
          ' openai_text.txt > changes.patch
          if [ ! -s changes.patch ]; then
            echo "No patch extracted from model output. Exiting."
            sed -n '1,120p' openai_text.txt
            exit 0
          fi
          echo "Extracted patch:"
          sed -n '1,200p' changes.patch

      - name: Apply patch & verify
        shell: bash
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          if ! git apply -p0 --whitespace=fix changes.patch; then
            echo "Patch did not apply cleanly."; exit 0
          fi
          echo "Patch applied. Building..."
          go version || true
          go mod tidy
          if ! go build ./...; then
            echo "Build still failing after patch; keeping branch for review."
          fi
          BRANCH="autofix/${GITHUB_SHA::7}"
          git checkout -b "$BRANCH"
          git add -A
          git commit -m "Auto-fix CI failures via OpenAI"
          git push -u origin "$BRANCH"

      - name: Open PR
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          BASE="${{ github.event.pull_request.base.ref || github.ref_name }}"
          gh pr create --base "${BASE}" --head "$BRANCH" \
            --title "Auto-fix: CI failures" \
            --body "This PR was opened automatically after CI failed. Logs were passed via Actions cache (not public artifacts). Edits generated by OpenAI model \`${OPENAI_MODEL}\`."
