name: calcAPI-ci.yaml

on:
  push:
    branches: [ "main" ]
    paths:
      - '**/*.go'
      - go.mod
      - go.sum
      - '.github/workflows/**'
  pull_request:
    branches: [ "main" ]
    paths:
      - '**/*.go'
      - go.mod
      - go.sum
      - '.github/workflows/**'

jobs:
  build:
    runs-on: ubuntu-latest
    env:
      SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
      NOTIFY: .github/workflows/notify.sh
      IMAGE: m4gapower/calcapi
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24.6'
          cache: true

      - name: Notify Start
        shell: bash
        run: |
          chmod +x "$NOTIFY"
          echo v1.63.4 > .golangci.version
          mkdir -p artifacts
          "$NOTIFY" ":bell: Starting ${{ github.event.repository.name }} CI - Run (#$GITHUB_RUN_NUMBER) Commit: ${{ github.event.head_commit.message }} :bell:" "$SLACK_WEBHOOK"

      - name: Cache golangci-lint binary
        id: lintcache
        uses: actions/cache@v4
        with:
          path: ~/go/bin/golangci-lint
          key: ${{ runner.os }}-golangci-${{ hashFiles('.golangci.version') }}

      - name: Install dependencies
        shell: bash
        run: |
          sudo apt-get update -y && sudo apt-get install -y jq
          go mod tidy
          go mod download
          if [ "${{ steps.lintcache.outputs.cache-hit }}" != "true" ]; then
            GOLANGCI_VERSION=$(cat .golangci.version || echo v1.63.4)
            go install github.com/golangci/golangci-lint/cmd/golangci-lint@${GOLANGCI_VERSION}
          fi

      - name: Run golangci-lint
        shell: bash
        run: |
          set +e
          "$NOTIFY" "Starting Step - Lint" "$SLACK_WEBHOOK"
          mkdir -p artifacts
          golangci-lint run 2>&1 | tee artifacts/lint.log
          STATUS=${PIPESTATUS[0]}
          OUTPUT=$(sed 's/"/\\"/g' artifacts/lint.log | sed ':a;N;$!ba;s/\n/\\n/g')
          if [ $STATUS -eq 0 ]; then
            "$NOTIFY" "Step - Lint ‚úÖ Success" "$SLACK_WEBHOOK"
          else
            "$NOTIFY" "Step - Lint ‚ùå Failed:\n\`\`\`$OUTPUT\`\`\`" "$SLACK_WEBHOOK"
            exit 1
          fi

      - name: Early Build
        shell: bash
        run: |
          set +e
          "$NOTIFY" "Starting Step - Early Build" "$SLACK_WEBHOOK"
          mkdir -p artifacts
          go build -v ./... 2>&1 | tee artifacts/build.log
          STATUS=${PIPESTATUS[0]}
          OUTPUT=$(cat artifacts/build.log)
          if [ $STATUS -eq 0 ]; then
            "$NOTIFY" "Step - Early Build ‚úÖ Success" "$SLACK_WEBHOOK"
          else
            "$NOTIFY" "Step - Early Build ‚ùå Failed\n\`\`\`$OUTPUT\`\`\`" "$SLACK_WEBHOOK"
            exit 1
          fi

      - name: Test
        shell: bash
        run: |
          set +e
          "$NOTIFY" "Starting Step - Test" "$SLACK_WEBHOOK"
          mkdir -p artifacts
          go test -v ./... 2>&1 | tee artifacts/test.log
          STATUS=${PIPESTATUS[0]}
          OUTPUT=$(sed 's/"/\\"/g' artifacts/test.log | sed ':a;N;$!ba;s/\n/\\n/g')
          if [ $STATUS -eq 0 ]; then
            "$NOTIFY" "Step - Test ‚úÖ Success" "$SLACK_WEBHOOK"
          else
            "$NOTIFY" "Step - Test ‚ùå Failed:\n\`\`\`$OUTPUT\`\`\`" "$SLACK_WEBHOOK"
            exit 1
          fi

      - name: Build Docker image
        shell: bash
        run: |
          set -o pipefail
          "$NOTIFY" "üê≥ Starting Step - Build Docker image" "$SLACK_WEBHOOK"
          mkdir -p artifacts
          docker build --progress=plain -t "$IMAGE:latest" . 2>&1 | tee artifacts/docker-build.log
          STATUS=${PIPESTATUS[0]}
          if [ $STATUS -eq 0 ]; then
            "$NOTIFY" "Step - Build Docker image ‚úÖ Success" "$SLACK_WEBHOOK"
          else
            "$NOTIFY" "Step - Build Docker image ‚ùå Failed" "$SLACK_WEBHOOK"
            exit 1
          fi

      - name: Run & Test container
        shell: bash
        run: |
          "$NOTIFY" "üß™ Starting Step - Run & Test container" "$SLACK_WEBHOOK"
          docker run -d --rm -p 8080:8080 --name mycalc_test "$IMAGE:latest"
          mkdir -p artifacts
          for i in {1..10}; do
            if curl -fsS --max-time 2 http://localhost:8080/health | jq -e -r '.status=="ok"' >/dev/null; then
              HEALTH_JSON=$(curl -fsS http://localhost:8080/health || echo '{}')
              echo "$HEALTH_JSON" > artifacts/health.json
              SHORT=$(echo "$HEALTH_JSON" | jq -c .)
              "$NOTIFY" "Step - Run & Test container ‚úÖ Success (on :8080)\nHealth: \`\`\`${SHORT}\`\`\`" "$SLACK_WEBHOOK"
              docker stop mycalc_test
              exit 0
            fi
            sleep 1
          done
          curl -fsS http://localhost:8080/health > artifacts/health.json || true
          docker logs mycalc_test > artifacts/container.log 2>&1 || true
          TAIL=$(tail -n 80 artifacts/container.log | sed 's/"/\\"/g' | sed ':a;N;$!ba;s/\n/\\n/g')
          "$NOTIFY" "Step - Run & Test container ‚ùå Failed (no healthy response)\nLast logs:\n\`\`\`${TAIL}\`\`\`" "$SLACK_WEBHOOK"
          docker stop mycalc_test || true
          exit 1

      - name: Compute next SemVer MINOR tag
        shell: bash
        run: |
          "$NOTIFY" "üî¢ Starting Step - Compute next SemVer MINOR tag" "$SLACK_WEBHOOK"
          LATEST_SEMVER=$(
            curl -s "https://hub.docker.com/v2/repositories/$IMAGE/tags/?page_size=100" |
            jq -r '[.results[].name | select(test("^[0-9]+\\.[0-9]+\\.[0-9]+$"))]
                    | sort_by(split(".")|map(tonumber)) | last // empty'
          )
          BASE=${LATEST_SEMVER:-1.0.0}
          IFS='.' read -r MAJOR MINOR PATCH <<< "$BASE"
          NEW_TAG="${MAJOR}.$((MINOR+1)).0"
          echo "new_tag=$NEW_TAG" >> "$GITHUB_ENV"
          "$NOTIFY" "Step - Compute tag ‚úÖ $BASE ‚Üí $NEW_TAG" "$SLACK_WEBHOOK"

      - name: Tag image with NEW_TAG
        shell: bash
        run: |
          "$NOTIFY" "üè∑Ô∏è Starting Step - Tag image as ${IMAGE}:${new_tag}" "$SLACK_WEBHOOK"
          docker tag "$IMAGE:latest" "$IMAGE:${new_tag}"
          "$NOTIFY" "Step - Tag image ‚úÖ ${IMAGE}:${new_tag}" "$SLACK_WEBHOOK"

      - name: Push image(s)
        shell: bash
        run: |
          "$NOTIFY" "üì§ Starting Step - Push image(s)" "$SLACK_WEBHOOK"
          echo "${{ secrets.DOCKERHUB_TOKEN }}" | docker login -u "${{ secrets.DOCKERHUB_USERNAME }}" --password-stdin
          docker push "$IMAGE:latest"
          docker push "$IMAGE:${new_tag}"
          "$NOTIFY" "Step - Push image(s) ‚úÖ $IMAGE:latest & $IMAGE:${new_tag}" "$SLACK_WEBHOOK"

      - name: Show changed files (logs) + notify
        shell: bash
        run: |
          COMPARE="https://github.com/${{ github.repository }}/compare/${{ github.event.before }}...${{ github.sha }}"
          CHANGES="$(git diff --name-status ${{ github.event.before }} ${{ github.sha }})"
          echo "Compare: $COMPARE"
          echo "$CHANGES"
          MSG=$'Changes in this push:\n'"$COMPARE"$'\n\n'"$CHANGES"
          "$NOTIFY" "$MSG" "$SLACK_WEBHOOK"

      - name: Final pipeline result
        if: success()
        shell: bash
        run: |
          "$NOTIFY" "üöÄ Pipeline completed successfully!" "$SLACK_WEBHOOK"

      - name: Save CI logs for autofix
        if: failure()
        uses: actions/cache/save@v4
        with:
          path: artifacts
          key: ci-logs-${{ github.run_id }}

      - name: Final pipeline failure
        if: failure()
        shell: bash
        run: |
          "$NOTIFY" "üî• Pipeline failed!" "$SLACK_WEBHOOK"

  autofix:
      needs: build
      if: ${{ always() && needs.build.result == 'failure' && (github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.pull_request.head.repo.full_name == github.repository)) }}
      runs-on: ubuntu-latest
      permissions: { contents: write, pull-requests: write }
      env:
        GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        GEMINI_MODEL: ${{ vars.GEMINI_MODEL || 'gemini-2.5-flash' }}

      steps:
        - name: Check out source
          uses: actions/checkout@v4
          with: { fetch-depth: 0 }

        - name: Install tools
          run: |
            sudo apt-get update -y
            sudo apt-get install -y jq perl file

        - name: Restore CI logs
          uses: actions/cache/restore@v4
          with:
            path: artifacts
            key: ci-logs-${{ github.run_id }}
            fail-on-cache-miss: true

        - name: Prepare prompt
          shell: bash
          run: |
            cat > prompt.txt << 'EOF'
            You are an expert Go developer and CI engineer.

            TASK
            ----
            From the CI logs below, produce a SINGLE unified diff that minimally fixes the issues.

            HARD CONSTRAINTS
            ----------------
            1) Output MUST be a RAW git unified diff ‚Äî *no* code fences, *no* prose, *no* markdown.
            2) First line MUST start with:  diff --git a/‚Ä¶ b/‚Ä¶
            3) Each file section MUST include:
              - diff --git a/P b/P
              - index <oldsha>..<newsha> 100644   (hashes may be dummy but syntactically valid)
              - --- a/P
              - +++ b/P
              - One or more @@ hunks with correct counts.
            4) In every hunk body, EVERY line MUST begin with exactly one of:
              ' ' (space)  for context/unchanged lines
              '+'          for additions
              '-'          for deletions
              '\'          only for the exact marker "\ No newline at end of file"
              (Blank lines MUST be represented as a single space line: " ")
            5) Hunk line counts MUST match the +/- totals you emit.
            6) Only modify files that exist in this repo.
            7) Ensure /health returns {"status":"ok"} and use: defer func(){ _ = zl.Sync() }() for zap.

            SAMPLE (format only)
            --------------------
            diff --git a/foo.go b/foo.go
            index 1111111..2222222 100644
            --- a/foo.go
            +++ b/foo.go
            @@ -1,2 +1,3 @@
            package main
            -func A() {}
            +func A() {}
            +func B() {}

            === LINT ===
            EOF
            cat artifacts/lint.log  2>/dev/null >> prompt.txt || true
            echo -e "\n=== BUILD ==="          >> prompt.txt
            cat artifacts/build.log 2>/dev/null >> prompt.txt || true
            echo -e "\n=== TEST ==="           >> prompt.txt
            cat artifacts/test.log  2>/dev/null >> prompt.txt || true
            echo -e "\n=== DOCKER BUILD ==="   >> prompt.txt
            cat artifacts/docker-build.log 2>/dev/null >> prompt.txt || true
            echo -e "\n=== HEALTH ==="         >> prompt.txt
            sed -e 's/^/HEALTH: /' artifacts/health.json 2>/dev/null >> prompt.txt || true
            wc -c prompt.txt || true

        - name: Call Gemini for patch
          id: gen
          shell: bash
          env: { LANG: C.UTF-8 }
          run: |
            if [ -z "$GEMINI_API_KEY" ]; then
              echo "GEMINI_API_KEY not set; skipping autofix."; exit 0
            fi
            KEY=$(printf "%s" "$GEMINI_API_KEY" | tr -d '\r\n ')
            MODEL=$(printf "%s" "$GEMINI_MODEL" | tr -d '\r\n ')
            BODY=$(jq -Rs '{contents:[{role:"user",parts:[{text:.}]}]}' < prompt.txt)

            curl -sS "https://generativelanguage.googleapis.com/v1beta/models/${MODEL}:generateContent" \
              -H "Content-Type: application/json" \
              -H "x-goog-api-key: ${KEY}" \
              -d "$BODY" > gemini_resp.json

            jq -r '[.candidates[]?.content.parts[]?.text // empty] | join("\n")' gemini_resp.json > ai_text.txt

            if grep -qE '^diff --git ' ai_text.txt || grep -qE '^```(diff|patch)\b' ai_text.txt; then
              echo "patch_present=true" >> "$GITHUB_OUTPUT"
            else
              echo "patch_present=false" >> "$GITHUB_OUTPUT"
              echo "No diff markers in ai_text.txt"
            fi

        - name: Extract & Sanitize Patch
          id: sanitize
          if: steps.gen.outputs.patch_present == 'true'
          shell: bash
          run: |
            set -euo pipefail
            # Strip BOM; CRLF->LF
            perl -0777 -pe 's/^\xEF\xBB\xBF//' ai_text.txt | sed 's/\r$//' > ai_text.clean

            # Prefer fenced block
            perl -0777 -ne 'if (/```(?:diff|patch)[^\n]*\n([\s\S]*?)\n```/s){print $1;exit}' ai_text.clean > changes.patch || true
            # Or from first diff --git
            if [ ! -s changes.patch ]; then
              perl -0777 -ne 'print $1 if /(diff --git [\s\S]*)/s' ai_text.clean > changes.patch || true
            fi
            # Trim any preamble so first line is diff --git
            if [ -s changes.patch ] && ! head -n1 changes.patch | grep -q '^diff --git '; then
              awk 'f{print} /^diff --git /{f=1;print}' ai_text.clean > changes.patch || true
            fi
            # Leave empty if invalid
            if head -n1 changes.patch | grep -q '^diff --git '; then
              echo "sanitized_patch=true" >> "$GITHUB_OUTPUT"
            else
              : > changes.patch
              echo "sanitized_patch=false" >> "$GITHUB_OUTPUT"
            fi

        - name: Repair patch (prefix missing context lines)
          id: repair
          if: steps.sanitize.outputs.sanitized_patch == 'true'
          shell: bash
          run: |
            awk '
              BEGIN{in_hunk=0}
              /^diff --git / {in_hunk=0; print; next}
              /^index /      {print; next}
              /^--- /        {print; next}
              /^\+\+\+ /     {print; next}
              /^@@ /         {in_hunk=1; print; next}
              {
                if(in_hunk){
                  if ($0 ~ /^( |\+|\-|\\ No newline at end of file)/) { print; }
                  else if ($0 == "") { print " "; }
                  else { print " " $0; }
                } else {
                  print;
                }
              }
            ' changes.patch > changes.fixed

            mv changes.fixed changes.patch
            printf "Repaired patch lines: "; wc -l < changes.patch

        - name: Validate Patch
          id: validate
          if: steps.gen.outputs.patch_present == 'true'
          shell: bash
          run: |
            set -e
            if git apply --check --verbose -p1 changes.patch; then
              echo "strip=p1" >> "$GITHUB_OUTPUT"
            elif git apply --check --verbose changes.patch; then
              echo "strip=none" >> "$GITHUB_OUTPUT"
            else
              echo "code_changed=false" >> "$GITHUB_OUTPUT"
              echo "Patch failed validation."; exit 0
            fi

        - name: Apply patch & verify
          id: apply
          if: steps.validate.outputs.strip
          shell: bash
          run: |
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"

            STRIP="${{ steps.validate.outputs.strip }}"
            if [ "$STRIP" = "p1" ]; then
              git apply --index --3way --whitespace=fix -p1 changes.patch || APPLY_FAIL=1
            else
              git apply --index --3way --whitespace=fix changes.patch || APPLY_FAIL=1
            fi

            if [ "${APPLY_FAIL:-0}" = "1" ]; then
              git reset --hard
              if [ "$STRIP" = "p1" ]; then
                git apply --index --3way --whitespace=fix changes.patch || { echo "code_changed=false" >> "$GITHUB_OUTPUT"; echo "Patch did not apply cleanly."; exit 0; }
              else
                git apply --index --3way --whitespace=fix -p1 changes.patch || { echo "code_changed=false" >> "$GITHUB_OUTPUT"; echo "Patch did not apply cleanly."; exit 0; }
              fi
            fi

            go mod tidy || true
            go build ./... || true
            echo "code_changed=true" >> "$GITHUB_OUTPUT"

        - name: Create Auto-Fix PR
          if: steps.apply.outputs.code_changed == 'true'
          uses: peter-evans/create-pull-request@v6
          with:
            token: ${{ secrets.GH_TOKEN }}
            branch: auto-fix/${{ github.run_id }}
            base: ${{ github.event.pull_request.base.ref || github.event.repository.default_branch }}
            commit-message: "Auto-fix: apply model-suggested changes"
            title: "Auto-fix: CI failures"
            body: |
              PR opened automatically after CI failed.
              Edits generated by Google Gemini model `${{ env.GEMINI_MODEL }}`.
              (Logs were passed between jobs via Actions cache.)
            add-paths: |
              **/*.go
              go.mod
              go.sum
              .golangci.yml
              .github/**/*
            author: "github-actions[bot] <41898282+github-actions[bot]@users.noreply.github.com>"
            committer: "github-actions[bot] <41898282+github-actions[bot]@users.noreply.github.com>"
            labels: |
              ci
              auto-fix
            delete-branch: true

        - name: Upload patch debug artifacts
          if: always()
          uses: actions/upload-artifact@v4
          with:
            name: autofix-patch-debug
            path: |
              prompt.txt
              gemini_resp.json
              ai_text.txt
              changes.patch
              artifacts/**
            if-no-files-found: ignore
