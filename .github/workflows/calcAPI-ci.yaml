name: calcAPI-ci.yaml

on:
  push:
    branches: [ "main" ]
    paths:
      - '**/*.go'
      - go.mod
      - go.sum
      - '.github/workflows/**'
  pull_request:
    branches: [ "main" ]
    paths:
      - '**/*.go'
      - go.mod
      - go.sum
      - '.github/workflows/**'

jobs:
  build:
    runs-on: ubuntu-latest
    env:
      SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
      NOTIFY: .github/workflows/notify.sh
      IMAGE: m4gapower/calcapi
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24.6'
          cache: true

      - name: Notify Start
        shell: bash
        run: |
          chmod +x "$NOTIFY"
          echo v1.63.4 > .golangci.version
          mkdir -p artifacts
          "$NOTIFY" ":bell: Starting ${{ github.event.repository.name }} CI - Run (#$GITHUB_RUN_NUMBER) Commit: ${{ github.event.head_commit.message }} :bell:" "$SLACK_WEBHOOK"

      - name: Cache golangci-lint binary
        id: lintcache
        uses: actions/cache@v4
        with:
          path: ~/go/bin/golangci-lint
          key: ${{ runner.os }}-golangci-${{ hashFiles('.golangci.version') }}

      - name: Install dependencies
        shell: bash
        run: |
          sudo apt-get update -y && sudo apt-get install -y jq
          go mod tidy
          go mod download
          if [ "${{ steps.lintcache.outputs.cache-hit }}" != "true" ]; then
            GOLANGCI_VERSION=$(cat .golangci.version || echo v1.63.4)
            go install github.com/golangci/golangci-lint/cmd/golangci-lint@${GOLANGCI_VERSION}
          fi

      - name: Run golangci-lint
        shell: bash
        run: |
          set +e
          "$NOTIFY" "Starting Step - Lint" "$SLACK_WEBHOOK"
          mkdir -p artifacts
          golangci-lint run 2>&1 | tee artifacts/lint.log
          STATUS=${PIPESTATUS[0]}
          OUTPUT=$(sed 's/"/\\"/g' artifacts/lint.log | sed ':a;N;$!ba;s/\n/\\n/g')
          if [ $STATUS -eq 0 ]; then
            "$NOTIFY" "Step - Lint ‚úÖ Success" "$SLACK_WEBHOOK"
          else
            "$NOTIFY" "Step - Lint ‚ùå Failed:\n\`\`\`$OUTPUT\`\`\`" "$SLACK_WEBHOOK"
            exit 1
          fi

      - name: Early Build
        shell: bash
        run: |
          set +e
          "$NOTIFY" "Starting Step - Early Build" "$SLACK_WEBHOOK"
          mkdir -p artifacts
          go build -v ./... 2>&1 | tee artifacts/build.log
          STATUS=${PIPESTATUS[0]}
          OUTPUT=$(cat artifacts/build.log)
          if [ $STATUS -eq 0 ]; then
            "$NOTIFY" "Step - Early Build ‚úÖ Success" "$SLACK_WEBHOOK"
          else
            "$NOTIFY" "Step - Early Build ‚ùå Failed\n\`\`\`$OUTPUT\`\`\`" "$SLACK_WEBHOOK"
            exit 1
          fi

      - name: Test
        shell: bash
        run: |
          set +e
          "$NOTIFY" "Starting Step - Test" "$SLACK_WEBHOOK"
          mkdir -p artifacts
          go test -v ./... 2>&1 | tee artifacts/test.log
          STATUS=${PIPESTATUS[0]}
          OUTPUT=$(sed 's/"/\\"/g' artifacts/test.log | sed ':a;N;$!ba;s/\n/\\n/g')
          if [ $STATUS -eq 0 ]; then
            "$NOTIFY" "Step - Test ‚úÖ Success" "$SLACK_WEBHOOK"
          else
            "$NOTIFY" "Step - Test ‚ùå Failed:\n\`\`\`$OUTPUT\`\`\`" "$SLACK_WEBHOOK"
            exit 1
          fi

      - name: Build Docker image
        shell: bash
        run: |
          set -o pipefail
          "$NOTIFY" "üê≥ Starting Step - Build Docker image" "$SLACK_WEBHOOK"
          mkdir -p artifacts
          docker build --progress=plain -t "$IMAGE:latest" . 2>&1 | tee artifacts/docker-build.log
          STATUS=${PIPESTATUS[0]}
          if [ $STATUS -eq 0 ]; then
            "$NOTIFY" "Step - Build Docker image ‚úÖ Success" "$SLACK_WEBHOOK"
          else
            "$NOTIFY" "Step - Build Docker image ‚ùå Failed" "$SLACK_WEBHOOK"
            exit 1
          fi

      - name: Run & Test container
        shell: bash
        run: |
          "$NOTIFY" "üß™ Starting Step - Run & Test container" "$SLACK_WEBHOOK"
          docker run -d --rm -p 8080:8080 --name mycalc_test "$IMAGE:latest"
          mkdir -p artifacts
          for i in {1..10}; do
            if curl -fsS --max-time 2 http://localhost:8080/health | jq -e -r '.status=="ok"' >/dev/null; then
              HEALTH_JSON=$(curl -fsS http://localhost:8080/health || echo '{}')
              echo "$HEALTH_JSON" > artifacts/health.json
              SHORT=$(echo "$HEALTH_JSON" | jq -c .)
              "$NOTIFY" "Step - Run & Test container ‚úÖ Success (on :8080)\nHealth: \`\`\`${SHORT}\`\`\`" "$SLACK_WEBHOOK"
              docker stop mycalc_test
              exit 0
            fi
            sleep 1
          done
          curl -fsS http://localhost:8080/health > artifacts/health.json || true
          docker logs mycalc_test > artifacts/container.log 2>&1 || true
          TAIL=$(tail -n 80 artifacts/container.log | sed 's/"/\\"/g' | sed ':a;N;$!ba;s/\n/\\n/g')
          "$NOTIFY" "Step - Run & Test container ‚ùå Failed (no healthy response)\nLast logs:\n\`\`\`${TAIL}\`\`\`" "$SLACK_WEBHOOK"
          docker stop mycalc_test || true
          exit 1

      - name: Compute next SemVer MINOR tag
        shell: bash
        run: |
          "$NOTIFY" "üî¢ Starting Step - Compute next SemVer MINOR tag" "$SLACK_WEBHOOK"
          LATEST_SEMVER=$(
            curl -s "https://hub.docker.com/v2/repositories/$IMAGE/tags/?page_size=100" |
            jq -r '[.results[].name | select(test("^[0-9]+\\.[0-9]+\\.[0-9]+$"))]
                    | sort_by(split(".")|map(tonumber)) | last // empty'
          )
          BASE=${LATEST_SEMVER:-1.0.0}
          IFS='.' read -r MAJOR MINOR PATCH <<< "$BASE"
          NEW_TAG="${MAJOR}.$((MINOR+1)).0"
          echo "new_tag=$NEW_TAG" >> "$GITHUB_ENV"
          "$NOTIFY" "Step - Compute tag ‚úÖ $BASE ‚Üí $NEW_TAG" "$SLACK_WEBHOOK"

      - name: Tag image with NEW_TAG
        shell: bash
        run: |
          "$NOTIFY" "üè∑Ô∏è Starting Step - Tag image as ${IMAGE}:${new_tag}" "$SLACK_WEBHOOK"
          docker tag "$IMAGE:latest" "$IMAGE:${new_tag}"
          "$NOTIFY" "Step - Tag image ‚úÖ ${IMAGE}:${new_tag}" "$SLACK_WEBHOOK"

      - name: Push image(s)
        shell: bash
        run: |
          "$NOTIFY" "üì§ Starting Step - Push image(s)" "$SLACK_WEBHOOK"
          echo "${{ secrets.DOCKERHUB_TOKEN }}" | docker login -u "${{ secrets.DOCKERHUB_USERNAME }}" --password-stdin
          docker push "$IMAGE:latest"
          docker push "$IMAGE:${new_tag}"
          "$NOTIFY" "Step - Push image(s) ‚úÖ $IMAGE:latest & $IMAGE:${new_tag}" "$SLACK_WEBHOOK"

      - name: Show changed files (logs) + notify
        shell: bash
        run: |
          COMPARE="https://github.com/${{ github.repository }}/compare/${{ github.event.before }}...${{ github.sha }}"
          CHANGES="$(git diff --name-status ${{ github.event.before }} ${{ github.sha }})"
          echo "Compare: $COMPARE"
          echo "$CHANGES"
          MSG=$'Changes in this push:\n'"$COMPARE"$'\n\n'"$CHANGES"
          "$NOTIFY" "$MSG" "$SLACK_WEBHOOK"

      - name: Final pipeline result
        if: success()
        shell: bash
        run: |
          "$NOTIFY" "üöÄ Pipeline completed successfully!" "$SLACK_WEBHOOK"

      - name: Save CI logs for autofix
        if: failure()
        uses: actions/cache/save@v4
        with:
          path: artifacts
          key: ci-logs-${{ github.run_id }}

      - name: Final pipeline failure
        if: failure()
        shell: bash
        run: |
          "$NOTIFY" "üî• Pipeline failed!" "$SLACK_WEBHOOK"

  autofix:
    needs: build
    if: ${{ always() && needs.build.result == 'failure' && (github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.pull_request.head.repo.full_name == github.repository)) }}
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    env:
      GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
      GEMINI_MODEL: ${{ vars.GEMINI_MODEL || 'gemini-2.5-flash' }}

    steps:
      - name: Check out source
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install tools
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq perl file

      - name: Restore CI logs
        uses: actions/cache/restore@v4
        with:
          path: artifacts
          key: ci-logs-${{ github.run_id }}
          fail-on-cache-miss: true

      - name: Prepare prompt
        shell: bash
        run: |
          {
            echo "You are an expert Go developer and CI engineer."
            echo "Task: Read the CI logs and return a SINGLE git-style unified diff that minimally fixes the issues."
            echo "Hard constraints:"
            echo " - Output EXACTLY what \`git diff\` would emit."
            echo " - Include 'diff --git a/<path> b/<path>', 'index', '---', '+++', and '@@' hunks."
            echo " - Hunk counts MUST match. No prose, no backticks, no nested code fences."
            echo " - Only modify files in this repo."
            echo " - Ensure /health returns {\"status\":\"ok\"}."
            echo " - Use: defer func(){ _ = zl.Sync() }() for zap."
            echo
            echo "=== LINT ===";  cat artifacts/lint.log  2>/dev/null || true;  echo
            echo "=== BUILD ==="; cat artifacts/build.log 2>/dev/null || true;  echo
            echo "=== TEST ===";  cat artifacts/test.log  2>/dev/null || true;  echo
            echo "=== DOCKER BUILD ==="; cat artifacts/docker-build.log 2>/dev/null || true; echo
            echo "=== HEALTH ==="; sed -e 's/^/HEALTH: /' artifacts/health.json 2>/dev/null || true
          } > prompt.txt
          wc -c prompt.txt || true

      - name: Call Gemini for patch
        id: gen
        shell: bash
        env:
          LANG: C.UTF-8
        run: |
          if [ -z "$GEMINI_API_KEY" ]; then
            echo "GEMINI_API_KEY not set; skipping autofix."; exit 0
          fi
          KEY=$(printf "%s" "$GEMINI_API_KEY" | tr -d '\r\n ')
          MODEL=$(printf "%s" "$GEMINI_MODEL" | tr -d '\r\n ')
          BODY=$(jq -Rs '{contents:[{role:"user",parts:[{text:.}]}]}' < prompt.txt)

          curl -sS "https://generativelanguage.googleapis.com/v1beta/models/${MODEL}:generateContent" \
            -H "Content-Type: application/json" \
            -H "x-goog-api-key: ${KEY}" \
            -d "$BODY" > gemini_resp.json

          jq -r '[.candidates[]?.content.parts[]?.text // empty] | join("\n")' gemini_resp.json > ai_text.txt

          # Detect presence of a diff in the raw text (no extraction here)
          if grep -qE '^diff --git ' ai_text.txt || grep -qE '^```(diff|patch)\b' ai_text.txt; then
            echo "patch_present=true" >> "$GITHUB_OUTPUT"
          else
            echo "patch_present=false" >> "$GITHUB_OUTPUT"
            echo "No obvious diff markers found in ai_text.txt"
          fi

      - name: Extract & Sanitize Patch
        id: sanitize
        if: steps.gen.outputs.patch_present == 'true'
        shell: bash
        run: |
          set -euo pipefail
          # Normalize: strip UTF-8 BOM, convert CRLF->LF
          perl -0777 -pe 's/^\xEF\xBB\xBF//' ai_text.txt | sed 's/\r$//' > ai_text.clean

          # 1) Prefer fenced ```diff/```patch block
          perl -0777 -ne 'if (/```(?:diff|patch)[^\n]*\n([\s\S]*?)\n```/s){print $1;exit}' ai_text.clean > changes.patch || true

          # 2) If still empty, capture from the first "diff --git" line to EOF
          if [ ! -s changes.patch ]; then
            perl -0777 -ne 'print $1 if /(diff --git [\s\S]*)/s' ai_text.clean > changes.patch || true
          fi

          # 3) If we captured the whole text (e.g., preamble + diff), trim to first diff header
          if [ -s changes.patch ] && ! head -n1 changes.patch | grep -q '^diff --git '; then
            awk 'f{print} /^diff --git /{f=1;print}' ai_text.clean > changes.patch || true
          fi

          # Final sanity: keep file if it starts with a git diff header
          if head -n1 changes.patch | grep -q '^diff --git '; then
            echo "sanitized_patch=true" >> "$GITHUB_OUTPUT"
            printf "Patch bytes: "; wc -c < changes.patch
            printf "Patch lines: "; wc -l < changes.patch
          else
            echo "sanitized_patch=false" >> "$GITHUB_OUTPUT"
            echo "No valid git-style diff could be extracted."
            : > changes.patch  # leave empty for clarity
          fi

      - name: Debug Inspect AI text & patch
        if: steps.gen.outputs.patch_present == 'true'
        shell: bash
        run: |
          set -euo pipefail
          for f in ai_text.txt ai_text.clean changes.patch; do
            if [ -f "$f" ]; then
              echo "===== $f : basic info ====="
              printf "bytes: "; wc -c < "$f" || true
              printf "lines: "; wc -l < "$f" || true
              printf "mime : "; file -bi "$f" || true
              echo "CRLF line count: $(grep -c $'\r$' "$f" || echo 0)"
              echo
              echo "===== $f : first 120 lines (numbered) ====="
              nl -ba "$f" | sed -n '1,120p' || true
              echo
              echo "===== $f : last 60 lines (numbered) ====="
              nl -ba "$f" | tail -n 60 || true
              echo
              echo "===== $f : show non-printing (sed -n l) first 80 lines ====="
              sed -n '1,80l' "$f" || true
              echo
            else
              echo "File not found: $f"
            fi
          done

      - name: Validate Patch
        if: steps.gen.outputs.patch_present == 'true' && steps.sanitize.outputs.sanitized_patch != 'false'
        id: validate
        shell: bash
        run: |
          set -e
          if git apply --check --verbose -p1 changes.patch; then
            echo "strip=p1" >> "$GITHUB_OUTPUT"
          elif git apply --check --verbose changes.patch; then
            echo "strip=none" >> "$GITHUB_OUTPUT"
          else
            echo "code_changed=false" >> "$GITHUB_OUTPUT"
            echo "Patch failed validation."; exit 0
          fi

      - name: Apply patch & verify
        id: apply
        if: steps.validate.outputs.strip
        shell: bash
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          STRIP="${{ steps.validate.outputs.strip }}"
          if [ "$STRIP" = "p1" ]; then
            git apply --index --3way --whitespace=fix -p1 changes.patch || APPLY_FAIL=1
          else
            git apply --index --3way --whitespace=fix changes.patch || APPLY_FAIL=1
          fi

          if [ "${APPLY_FAIL:-0}" = "1" ]; then
            git reset --hard
            if [ "$STRIP" = "p1" ]; then
              git apply --index --3way --whitespace=fix changes.patch || { echo "code_changed=false" >> "$GITHUB_OUTPUT"; echo "Patch did not apply cleanly."; exit 0; }
            else
              git apply --index --3way --whitespace=fix -p1 changes.patch || { echo "code_changed=false" >> "$GITHUB_OUTPUT"; echo "Patch did not apply cleanly."; exit 0; }
            fi
          fi

          go mod tidy || true
          go build ./... || true
          echo "code_changed=true" >> "$GITHUB_OUTPUT"

      - name: Create Auto-Fix PR
        if: steps.apply.outputs.code_changed == 'true'
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.GH_TOKEN }}
          branch: auto-fix/${{ github.run_id }}
          base: ${{ github.event.pull_request.base.ref || github.event.repository.default_branch }}
          commit-message: "Auto-fix: apply model-suggested changes"
          title: "Auto-fix: CI failures"
          body: |
            PR opened automatically after CI failed.
            Edits generated by Google Gemini model `${{ env.GEMINI_MODEL }}`.
            (Logs were passed between jobs via Actions cache.)
          add-paths: |
            **/*.go
            go.mod
            go.sum
            .golangci.yml
            .github/**/*
          author: "github-actions[bot] <41898282+github-actions[bot]@users.noreply.github.com>"
          committer: "github-actions[bot] <41898282+github-actions[bot]@users.noreply.github.com>"
          labels: |
            ci
            auto-fix
          delete-branch: true

      - name: Upload patch debug artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: autofix-patch-debug
          path: |
            prompt.txt
            gemini_resp.json
            ai_text.txt
            ai_text.clean
            changes.patch
            artifacts/**
          if-no-files-found: ignore
