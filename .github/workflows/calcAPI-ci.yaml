name: calcAPI-ci.yaml

on:
  push:
    branches: [ "main" ]
    paths:
      - '**/*.go'
      - go.mod
      - go.sum
      - '.github/workflows/**'
  pull_request:
    branches: [ "main" ]
    paths:
      - '**/*.go'
      - go.mod
      - go.sum
      - '.github/workflows/**'

jobs:
  build:
    runs-on: ubuntu-latest
    env:
      SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
      NOTIFY: .github/workflows/notify.sh
      IMAGE: m4gapower/calcapi   # must be lowercase for Docker
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24.6'
          cache: true

      - name: Notify Start
        shell: bash
        run: |
          chmod +x "$NOTIFY"
          echo v1.63.4 > .golangci.version
          mkdir -p artifacts
          "$NOTIFY" ":bell: Starting ${{ github.event.repository.name }} CI - Run (#$GITHUB_RUN_NUMBER) Commit: ${{ github.event.head_commit.message }} :bell:" "$SLACK_WEBHOOK"

      - name: Cache golangci-lint binary
        id: lintcache
        uses: actions/cache@v4
        with:
          path: ~/go/bin/golangci-lint
          key: ${{ runner.os }}-golangci-${{ hashFiles('.golangci.version') }}

      - name: Install dependencies
        shell: bash
        run: |
          sudo apt-get update -y && sudo apt-get install -y jq
          go mod tidy
          go mod download
          if [ "${{ steps.lintcache.outputs.cache-hit }}" != "true" ]; then
            GOLANGCI_VERSION=$(cat .golangci.version || echo v1.63.4)
            go install github.com/golangci/golangci-lint/cmd/golangci-lint@${GOLANGCI_VERSION}
          fi

      - name: Run golangci-lint
        shell: bash
        run: |
          set +e
          "$NOTIFY" "Starting Step - Lint" "$SLACK_WEBHOOK"
          mkdir -p artifacts
          golangci-lint run 2>&1 | tee artifacts/lint.log
          STATUS=${PIPESTATUS[0]}
          OUTPUT=$(sed 's/"/\\"/g' artifacts/lint.log | sed ':a;N;$!ba;s/\n/\\n/g')
          if [ $STATUS -eq 0 ]; then
            "$NOTIFY" "Step - Lint ‚úÖ Success" "$SLACK_WEBHOOK"
          else
            "$NOTIFY" "Step - Lint ‚ùå Failed:\n\`\`\`$OUTPUT\`\`\`" "$SLACK_WEBHOOK"
            exit 1
          fi

      - name: Early Build
        shell: bash
        run: |
          set +e
          "$NOTIFY" "Starting Step - Early Build" "$SLACK_WEBHOOK"
          mkdir -p artifacts
          go build -v ./... 2>&1 | tee artifacts/build.log
          STATUS=${PIPESTATUS[0]}
          OUTPUT=$(cat artifacts/build.log)
          if [ $STATUS -eq 0 ]; then
            "$NOTIFY" "Step - Early Build ‚úÖ Success" "$SLACK_WEBHOOK"
          else
            "$NOTIFY" "Step - Early Build ‚ùå Failed\n\`\`\`$OUTPUT\`\`\`" "$SLACK_WEBHOOK"
            exit 1
          fi

      - name: Test
        shell: bash
        run: |
          set +e
          "$NOTIFY" "Starting Step - Test" "$SLACK_WEBHOOK"
          mkdir -p artifacts
          go test -v ./... 2>&1 | tee artifacts/test.log
          STATUS=${PIPESTATUS[0]}
          OUTPUT=$(sed 's/"/\\"/g' artifacts/test.log | sed ':a;N;$!ba;s/\n/\\n/g')
          if [ $STATUS -eq 0 ]; then
            "$NOTIFY" "Step - Test ‚úÖ Success" "$SLACK_WEBHOOK"
          else
            "$NOTIFY" "Step - Test ‚ùå Failed:\n\`\`\`$OUTPUT\`\`\`" "$SLACK_WEBHOOK"
            exit 1
          fi

      - name: Build Docker image
        shell: bash
        run: |
          set -o pipefail
          "$NOTIFY" "üê≥ Starting Step - Build Docker image" "$SLACK_WEBHOOK"
          mkdir -p artifacts
          docker build --progress=plain -t "$IMAGE:latest" . 2>&1 | tee artifacts/docker-build.log
          STATUS=${PIPESTATUS[0]}
          if [ $STATUS -eq 0 ]; then
            "$NOTIFY" "Step - Build Docker image ‚úÖ Success" "$SLACK_WEBHOOK"
          else
            "$NOTIFY" "Step - Build Docker image ‚ùå Failed" "$SLACK_WEBHOOK"
            exit 1
          fi

      - name: Run & Test container
        shell: bash
        run: |
          "$NOTIFY" "üß™ Starting Step - Run & Test container" "$SLACK_WEBHOOK"
          docker run -d --rm -p 8080:8080 --name mycalc_test "$IMAGE:latest"
          mkdir -p artifacts
          for i in {1..10}; do
            if curl -fsS --max-time 2 http://localhost:8080/health | jq -e -r '.status=="ok"' >/dev/null; then
              HEALTH_JSON=$(curl -fsS http://localhost:8080/health || echo '{}')
              echo "$HEALTH_JSON" > artifacts/health.json
              SHORT=$(echo "$HEALTH_JSON" | jq -c .)
              "$NOTIFY" "Step - Run & Test container ‚úÖ Success (on :8080)\nHealth: \`\`\`${SHORT}\`\`\`" "$SLACK_WEBHOOK"
              docker stop mycalc_test
              exit 0
            fi
            sleep 1
          done
          curl -fsS http://localhost:8080/health > artifacts/health.json || true
          docker logs mycalc_test > artifacts/container.log 2>&1 || true
          TAIL=$(tail -n 80 artifacts/container.log | sed 's/"/\\"/g' | sed ':a;N;$!ba;s/\n/\\n/g')
          "$NOTIFY" "Step - Run & Test container ‚ùå Failed (no healthy response)\nLast logs:\n\`\`\`${TAIL}\`\`\`" "$SLACK_WEBHOOK"
          docker stop mycalc_test || true
          exit 1

      - name: Compute next SemVer MINOR tag
        shell: bash
        run: |
          "$NOTIFY" "üî¢ Starting Step - Compute next SemVer MINOR tag" "$SLACK_WEBHOOK"
          LATEST_SEMVER=$(
            curl -s "https://hub.docker.com/v2/repositories/$IMAGE/tags/?page_size=100" |
            jq -r '[.results[].name | select(test("^[0-9]+\\.[0-9]+\\.[0-9]+$"))]
                    | sort_by(split(".")|map(tonumber)) | last // empty'
          )
          BASE=${LATEST_SEMVER:-1.0.0}
          IFS='.' read -r MAJOR MINOR PATCH <<< "$BASE"
          NEW_TAG="${MAJOR}.$((MINOR+1)).0"
          echo "new_tag=$NEW_TAG" >> "$GITHUB_ENV"
          "$NOTIFY" "Step - Compute tag ‚úÖ $BASE ‚Üí $NEW_TAG" "$SLACK_WEBHOOK"

      - name: Tag image with NEW_TAG
        shell: bash
        run: |
          "$NOTIFY" "üè∑Ô∏è Starting Step - Tag image as ${IMAGE}:${new_tag}" "$SLACK_WEBHOOK"
          docker tag "$IMAGE:latest" "$IMAGE:${new_tag}"
          "$NOTIFY" "Step - Tag image ‚úÖ ${IMAGE}:${new_tag}" "$SLACK_WEBHOOK"

      - name: Push image(s)
        shell: bash
        run: |
          "$NOTIFY" "üì§ Starting Step - Push image(s)" "$SLACK_WEBHOOK"
          echo "${{ secrets.DOCKERHUB_TOKEN }}" | docker login -u "${{ secrets.DOCKERHUB_USERNAME }}" --password-stdin
          docker push "$IMAGE:latest"
          docker push "$IMAGE:${new_tag}"
          "$NOTIFY" "Step - Push image(s) ‚úÖ $IMAGE:latest & $IMAGE:${new_tag}" "$SLACK_WEBHOOK"

      - name: Show changed files (logs) + notify
        shell: bash
        run: |
          COMPARE="https://github.com/${{ github.repository }}/compare/${{ github.event.before }}...${{ github.sha }}"
          CHANGES="$(git diff --name-status ${{ github.event.before }} ${{ github.sha }})"
          echo "Compare: $COMPARE"
          echo "$CHANGES"
          MSG=$'Changes in this push:\n'"$COMPARE"$'\n\n'"$CHANGES"
          "$NOTIFY" "$MSG" "$SLACK_WEBHOOK"

      - name: Final pipeline result
        if: success()
        shell: bash
        run: |
          "$NOTIFY" "üöÄ Pipeline completed successfully!" "$SLACK_WEBHOOK"

      - name: Save CI logs for autofix
        if: failure()
        uses: actions/cache/save@v4
        with:
          path: artifacts
          key: ci-logs-${{ github.run_id }}

      - name: Final pipeline failure
        if: failure()
        shell: bash
        run: |
          "$NOTIFY" "üî• Pipeline failed!" "$SLACK_WEBHOOK"

  autofix:
    needs: build
    if: ${{ always() && needs.build.result == 'failure' && (github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.pull_request.head.repo.full_name == github.repository)) }}
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    env:
      GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
      GEMINI_MODEL: ${{ vars.GEMINI_MODEL || 'gemini-2.5-flash' }}
    steps:
      - name: Check out source
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install tools
        run: sudo apt-get update -y && sudo apt-get install -y jq

      - name: Restore CI logs
        uses: actions/cache/restore@v4
        with:
          path: artifacts
          key: ci-logs-${{ github.run_id }}
          fail-on-cache-miss: true

      - name: Prepare prompt
        shell: bash
        run: |
          {
            echo "You are an expert Go developer and CI engineer."
            echo "Task: Read the CI logs (lint/test/build/docker) and return a SINGLE unified diff patch that fixes issues with minimal changes."
            echo "Constraints:"
            echo " - Only change files in this repo."
            echo " - Keep code style consistent."
            echo " - Ensure /health returns {\"status\":\"ok\"}."
            echo " - Use defer func(){ _ = zl.Sync() }() for zap."
            echo "Output format: ONLY a fenced diff block:"
            echo '```diff'
            echo '--- a/path'
            echo '+++ b/path'
            echo '@@ ...'
            echo '```'
            echo
            echo "=== LINT ===";  cat artifacts/lint.log  2>/dev/null || true;  echo
            echo "=== BUILD ==="; cat artifacts/build.log 2>/dev/null || true;  echo
            echo "=== TEST ===";  cat artifacts/test.log  2>/dev/null || true;  echo
            echo "=== DOCKER BUILD ==="; cat artifacts/docker-build.log 2>/dev/null || true; echo
            echo "=== HEALTH ==="; sed -e 's/^/HEALTH: /' artifacts/health.json 2>/dev/null || true
          } > prompt.txt
          wc -c prompt.txt || true

      - name: Call Gemini for patch
        shell: bash
        env:
            LANG: C.UTF-8
        run: |
            # Trim any CR/LF/space from secrets/vars
            KEY=$(printf "%s" "$GEMINI_API_KEY" | tr -d '\r\n ')
            MODEL=$(printf "%s" "$GEMINI_MODEL"     | tr -d '\r\n ')

            if [ -z "$KEY" ]; then
            echo "GEMINI_API_KEY not set; skipping autofix."
            exit 0
            fi

            BODY=$(jq -Rs '{contents:[{role:"user",parts:[{text:.}]}]}' < prompt.txt)

            # Use header for API key (avoids URL issues)
            curl -sS "https://generativelanguage.googleapis.com/v1beta/models/${MODEL}:generateContent" \
            -H "Content-Type: application/json" \
            -H "x-goog-api-key: ${KEY}" \
            -d "$BODY" > gemini_resp.json

            jq -r '[.candidates[]?.content.parts[]?.text // empty] | join("\n")' gemini_resp.json > ai_text.txt
            awk '/^```(diff|patch)/{f=1;next} /^```/{if(f){f=0;next}} f' ai_text.txt > changes.patch
            if [ ! -s changes.patch ]; then
            echo "No patch extracted from model output. Exiting."
            sed -n '1,120p' ai_text.txt
            exit 0
            fi
            echo "Extracted patch:"; sed -n '1,200p' changes.patch

      - name: Apply patch & verify
        shell: bash
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          if ! git apply -p0 --whitespace=fix changes.patch; then
            echo "Patch did not apply cleanly."; exit 0
          fi
          echo "Patch applied. Building..."
          go version || true
          go mod tidy
          if ! go build ./...; then
            echo "Build still failing after patch; keeping branch for review."
          fi
          BRANCH="autofix/${GITHUB_SHA::7}"
          git checkout -b "$BRANCH"
          git add -A
          git commit -m "Auto-fix CI failures via Gemini"
          git push -u origin "$BRANCH"

      - name: Open PR
        env:
            GH_TOKEN: ${{ secrets.GH_TOKEN }}               # your PAT name (screenshot)
            REPO: ${{ github.repository }}
            BASE_REF: ${{ github.event.pull_request.base.ref }}
            DEFAULT_BRANCH: ${{ github.event.repository.default_branch }}
            HEAD_REF: ${{ github.head_ref }}
            REF_NAME: ${{ github.ref_name }}
            RUN_ID: ${{ github.run_id }}
            GEMINI_MODEL: gemini-2.5-flash
        run: |
            set -Eeuo pipefail

            git config user.name  "github-actions[bot]"
            git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
            git fetch --prune --unshallow || true

            BASE="${BASE_REF:-${DEFAULT_BRANCH:-main}}"

            # Detect current branch across push/PR events (handles detached HEAD)
            HEAD_BRANCH="${HEAD_REF:-${REF_NAME:-}}"
            if [ -z "$HEAD_BRANCH" ] || [ "$HEAD_BRANCH" = "HEAD" ]; then
            HEAD_BRANCH="$(git rev-parse --abbrev-ref HEAD || true)"
            fi
            [ -z "$HEAD_BRANCH" ] && HEAD_BRANCH="$BASE"

            # If head==base, use a temp branch to avoid "No commits between ..."
            if [ "$HEAD_BRANCH" = "$BASE" ]; then
            HEAD_BRANCH="auto-fix/${RUN_ID}"
            git switch -c "$HEAD_BRANCH" "origin/$BASE" || git switch -c "$HEAD_BRANCH" "$BASE"
            fi

            git add -A
            if git diff --cached --quiet; then
            echo "No changes to commit; skipping PR."
            exit 0
            fi

            git commit -m "Auto-fix: include generated changes"

            # Ensure pushes use your PAT even if checkout used default token
            git remote set-url origin "https://x-access-token:${GH_TOKEN}@github.com/${REPO}.git"
            git push -u origin "$HEAD_BRANCH"

            # Make sure gh is using the token and repo
            gh auth status || echo "$GH_TOKEN" | gh auth login --with-token
            gh repo set-default "$REPO"

            # Create PR (or show what's blocking)
            if ! gh pr create --base "$BASE" --head "$HEAD_BRANCH" \
                --title "Auto-fix: CI failures" \
                --body "PR opened automatically after CI failed. Edits by \`${GEMINI_MODEL}\`."; then
            echo "::group::PR diagnostics"
            gh pr list --head "$HEAD_BRANCH" --state all --limit 5 || true
            gh pr status || true
            echo "::endgroup::"
            exit 1
            fi







