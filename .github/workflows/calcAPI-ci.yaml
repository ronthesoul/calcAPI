name: calcAPI-ci.yaml

on:
  push:
    branches: [ "main" ]
    paths:
      - '**/*.go'
      - go.mod
      - go.sum
      - '.github/workflows/**'
  pull_request:
    branches: [ "main" ]
    paths:
      - '**/*.go'
      - go.mod
      - go.sum
      - '.github/workflows/**'

jobs:
  build:
    runs-on: ubuntu-latest
    env:
      SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
      NOTIFY: .github/workflows/notify.sh
      IMAGE: m4gapower/calcapi
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24.6'
          cache: true

      - name: Notify Start
        shell: bash
        run: |
          chmod +x "$NOTIFY"
          echo v1.63.4 > .golangci.version
          mkdir -p artifacts
          "$NOTIFY" ":bell: Starting ${{ github.event.repository.name }} CI - Run (#$GITHUB_RUN_NUMBER) Commit: ${{ github.event.head_commit.message }} :bell:" "$SLACK_WEBHOOK"

      - name: Cache golangci-lint binary
        id: lintcache
        uses: actions/cache@v4
        with:
          path: ~/go/bin/golangci-lint
          key: ${{ runner.os }}-golangci-${{ hashFiles('.golangci.version') }}

      - name: Install dependencies
        shell: bash
        run: |
          sudo apt-get update -y && sudo apt-get install -y jq
          go mod tidy
          go mod download
          if [ "${{ steps.lintcache.outputs.cache-hit }}" != "true" ]; then
            GOLANGCI_VERSION=$(cat .golangci.version || echo v1.63.4)
            go install github.com/golangci/golangci-lint/cmd/golangci-lint@${GOLANGCI_VERSION}
          fi

      - name: Run golangci-lint
        shell: bash
        run: |
          set +e
          "$NOTIFY" "Starting Step - Lint" "$SLACK_WEBHOOK"
          mkdir -p artifacts
          golangci-lint run 2>&1 | tee artifacts/lint.log
          STATUS=${PIPESTATUS[0]}
          OUTPUT=$(sed 's/"/\\"/g' artifacts/lint.log | sed ':a;N;$!ba;s/\n/\\n/g')
          if [ $STATUS -eq 0 ]; then
            "$NOTIFY" "Step - Lint ‚úÖ Success" "$SLACK_WEBHOOK"
          else
            "$NOTIFY" "Step - Lint ‚ùå Failed:\n\`\`\`$OUTPUT\`\`\`" "$SLACK_WEBHOOK"
            exit 1
          fi

      - name: Early Build
        shell: bash
        run: |
          set +e
          "$NOTIFY" "Starting Step - Early Build" "$SLACK_WEBHOOK"
          mkdir -p artifacts
          go build -v ./... 2>&1 | tee artifacts/build.log
          STATUS=${PIPESTATUS[0]}
          OUTPUT=$(cat artifacts/build.log)
          if [ $STATUS -eq 0 ]; then
            "$NOTIFY" "Step - Early Build ‚úÖ Success" "$SLACK_WEBHOOK"
          else
            "$NOTIFY" "Step - Early Build ‚ùå Failed\n\`\`\`$OUTPUT\`\`\`" "$SLACK_WEBHOOK"
            exit 1
          fi

      - name: Test
        shell: bash
        run: |
          set +e
          "$NOTIFY" "Starting Step - Test" "$SLACK_WEBHOOK"
          mkdir -p artifacts
          go test -v ./... 2>&1 | tee artifacts/test.log
          STATUS=${PIPESTATUS[0]}
          OUTPUT=$(sed 's/"/\\"/g' artifacts/test.log | sed ':a;N;$!ba;s/\n/\\n/g')
          if [ $STATUS -eq 0 ]; then
            "$NOTIFY" "Step - Test ‚úÖ Success" "$SLACK_WEBHOOK"
          else
            "$NOTIFY" "Step - Test ‚ùå Failed:\n\`\`\`$OUTPUT\`\`\`" "$SLACK_WEBHOOK"
            exit 1
          fi

      - name: Build Docker image
        shell: bash
        run: |
          set -o pipefail
          "$NOTIFY" "üê≥ Starting Step - Build Docker image" "$SLACK_WEBHOOK"
          mkdir -p artifacts
          docker build --progress=plain -t "$IMAGE:latest" . 2>&1 | tee artifacts/docker-build.log
          STATUS=${PIPESTATUS[0]}
          if [ $STATUS -eq 0 ]; then
            "$NOTIFY" "Step - Build Docker image ‚úÖ Success" "$SLACK_WEBHOOK"
          else
            "$NOTIFY" "Step - Build Docker image ‚ùå Failed" "$SLACK_WEBHOOK"
            exit 1
          fi

      - name: Run & Test container
        shell: bash
        run: |
          "$NOTIFY" "üß™ Starting Step - Run & Test container" "$SLACK_WEBHOOK"
          docker run -d --rm -p 8080:8080 --name mycalc_test "$IMAGE:latest"
          mkdir -p artifacts
          for i in {1..10}; do
            if curl -fsS --max-time 2 http://localhost:8080/health | jq -e -r '.status=="ok"' >/dev/null; then
              HEALTH_JSON=$(curl -fsS http://localhost:8080/health || echo '{}')
              echo "$HEALTH_JSON" > artifacts/health.json
              SHORT=$(echo "$HEALTH_JSON" | jq -c .)
              "$NOTIFY" "Step - Run & Test container ‚úÖ Success (on :8080)\nHealth: \`\`\`${SHORT}\`\`\`" "$SLACK_WEBHOOK"
              docker stop mycalc_test
              exit 0
            fi
            sleep 1
          done
          curl -fsS http://localhost:8080/health > artifacts/health.json || true
          docker logs mycalc_test > artifacts/container.log 2>&1 || true
          TAIL=$(tail -n 80 artifacts/container.log | sed 's/"/\\"/g' | sed ':a;N;$!ba;s/\n/\\n/g')
          "$NOTIFY" "Step - Run & Test container ‚ùå Failed (no healthy response)\nLast logs:\n\`\`\`${TAIL}\`\`\`" "$SLACK_WEBHOOK"
          docker stop mycalc_test || true
          exit 1

      - name: Compute next SemVer MINOR tag
        shell: bash
        run: |
          "$NOTIFY" "üî¢ Starting Step - Compute next SemVer MINOR tag" "$SLACK_WEBHOOK"
          LATEST_SEMVER=$(
            curl -s "https://hub.docker.com/v2/repositories/$IMAGE/tags/?page_size=100" |
            jq -r '[.results[].name | select(test("^[0-9]+\\.[0-9]+\\.[0-9]+$"))]
                    | sort_by(split(".")|map(tonumber)) | last // empty'
          )
          BASE=${LATEST_SEMVER:-1.0.0}
          IFS='.' read -r MAJOR MINOR PATCH <<< "$BASE"
          NEW_TAG="${MAJOR}.$((MINOR+1)).0"
          echo "new_tag=$NEW_TAG" >> "$GITHUB_ENV"
          "$NOTIFY" "Step - Compute tag ‚úÖ $BASE ‚Üí $NEW_TAG" "$SLACK_WEBHOOK"

      - name: Tag image with NEW_TAG
        shell: bash
        run: |
          "$NOTIFY" "üè∑Ô∏è Starting Step - Tag image as ${IMAGE}:${new_tag}" "$SLACK_WEBHOOK"
          docker tag "$IMAGE:latest" "$IMAGE:${new_tag}"
          "$NOTIFY" "Step - Tag image ‚úÖ ${IMAGE}:${new_tag}" "$SLACK_WEBHOOK"

      - name: Push image(s)
        shell: bash
        run: |
          "$NOTIFY" "üì§ Starting Step - Push image(s)" "$SLACK_WEBHOOK"
          echo "${{ secrets.DOCKERHUB_TOKEN }}" | docker login -u "${{ secrets.DOCKERHUB_USERNAME }}" --password-stdin
          docker push "$IMAGE:latest"
          docker push "$IMAGE:${new_tag}"
          "$NOTIFY" "Step - Push image(s) ‚úÖ $IMAGE:latest & $IMAGE:${new_tag}" "$SLACK_WEBHOOK"

      - name: Show changed files (logs) + notify
        shell: bash
        run: |
          COMPARE="https://github.com/${{ github.repository }}/compare/${{ github.event.before }}...${{ github.sha }}"
          CHANGES="$(git diff --name-status ${{ github.event.before }} ${{ github.sha }})"
          echo "Compare: $COMPARE"
          echo "$CHANGES"
          MSG=$'Changes in this push:\n'"$COMPARE"$'\n\n'"$CHANGES"
          "$NOTIFY" "$MSG" "$SLACK_WEBHOOK"

      - name: Final pipeline result
        if: success()
        shell: bash
        run: |
          "$NOTIFY" "üöÄ Pipeline completed successfully!" "$SLACK_WEBHOOK"

      - name: Save CI logs for autofix
        if: failure()
        uses: actions/cache/save@v4
        with:
          path: artifacts
          key: ci-logs-${{ github.run_id }}

      - name: Final pipeline failure
        if: failure()
        shell: bash
        run: |
          "$NOTIFY" "üî• Pipeline failed!" "$SLACK_WEBHOOK"

  autofix:
      needs: build
      if: ${{ always() && needs.build.result == 'failure' && (github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.pull_request.head.repo.full_name == github.repository)) }}
      runs-on: ubuntu-latest
      permissions: { contents: write, pull-requests: write, models: read }
      env:
        GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        GEMINI_MODEL: ${{ vars.GEMINI_MODEL || 'gemini-2.5-flash' }}

      steps:
        - name: Check out source
          uses: actions/checkout@v4
          with: { fetch-depth: 0 }

        - name: Install tools
          run: |
            sudo apt-get update -y
            sudo apt-get install -y jq perl file python3-pip patch

        - name: Restore CI logs
          uses: actions/cache/restore@v4
          with:
            path: artifacts
            key: ci-logs-${{ github.run_id }}
            fail-on-cache-miss: true

        - name: Prepare prompt
          shell: bash
          run: |
            cat > prompt.txt << 'EOF'
            You are an expert Go developer and CI engineer.

            TASK
            ----
            From the CI logs below, produce a SINGLE unified diff that minimally fixes the issues.

            HARD CONSTRAINTS
            ----------------
            1) Output MUST be a RAW git unified diff ‚Äî no code fences, no prose, no markdown.
            2) First line MUST start with:  diff --git a/... b/...
            3) Each file section MUST include:
              - diff --git a/P b/P
              - index <oldsha>..<newsha> 100644
              - --- a/P
              - +++ b/P
              - @@ hunks ‚Ä¶
            4) Only modify files that exist in this repo.

            === LINT ===
            EOF
            cat artifacts/lint.log  2>/dev/null >> prompt.txt || true
            echo -e "\n=== BUILD ==="        >> prompt.txt
            cat artifacts/build.log 2>/dev/null >> prompt.txt || true
            echo -e "\n=== TEST ==="         >> prompt.txt
            cat artifacts/test.log  2>/dev/null >> prompt.txt || true
            echo -e "\n=== DOCKER BUILD ===" >> prompt.txt
            cat artifacts/docker-build.log 2>/dev/null >> prompt.txt || true
            echo -e "\n=== HEALTH ==="       >> prompt.txt
            sed -e 's/^/HEALTH: /' artifacts/health.json 2>/dev/null >> prompt.txt || true
            echo 'Please reply with a git diff that can be applied with "git apply" to fix the issues above.' >> prompt.txt

        - name: Run AI inference (generate unified diff)
          id: inference
          uses: actions/ai-inference@v1
          with:
            # pick a model available in GitHub Models; examples:
            # model: openai/gpt-4o
            # model: openai/gpt-4o-mini
            # model: meta/llama-3.1-70b-instruct
            model: openai/gpt-4o
            prompt: |
              ${{ steps.build_prompt.outputs.text || '' }}
              # Fallback: read the prompt file if you prefer:
              # (ai-inference supports only inline input; we cat the file below)
        - name: Save/normalize AI output to patch.diff
          shell: bash
          run: |
            # If you built prompt.txt above and prefer exact contents, you can do:
            #   PROMPT="$(cat prompt.txt)"
            # and pass it to ai-inference via `with: prompt: ${{ steps.read_prompt.outputs.prompt }}`.

            # Write raw AI response
            printf '%s\n' "${{ steps.inference.outputs.response }}" > patch.raw

            # Strip code fences if present
            sed -i '/^```.*$/d' patch.raw

            # Normalize CRLF
            sed -i 's/\r$//' patch.raw

            # Trim to first 'diff --git' line
            awk 'BEGIN{p=0} /^diff --git /{p=1} p{print}' patch.raw > patch.diff

            # If not found, declare NOOP and skip later
            if [ ! -s patch.diff ]; then
              echo NOOP > patch.diff
              echo "no_usable_diff=true" >> $GITHUB_OUTPUT
            else
              echo "no_usable_diff=false" >> $GITHUB_OUTPUT
              head -n 1 patch.diff | grep -q '^diff --git ' || (echo "Not a raw unified diff"; exit 78)
            fi

        - name: Apply patch (robust)
          id: apply
          shell: bash
          run: |
            set -euo pipefail
            git config user.name  "ci-autofix-bot"
            git config user.email "ci-autofix-bot@users.noreply.github.com"

            # If generator wrote NOOP, skip cleanly
            if grep -qx 'NOOP' patch.diff 2>/dev/null; then
              echo "No usable diff; skipping apply."
              echo "changed_files=0" >> "$GITHUB_OUTPUT"
              exit 0
            fi

            # Normalize & clean
            sed -i 's/\r$//' patch.diff || true                             # CRLF -> LF
            sed -i '1 s/^\xEF\xBB\xBF//' patch.diff || true                 # strip UTF-8 BOM
            sed -i '/^```.*$/d' patch.diff || true                          # remove code fences

            # Trim everything BEFORE the first 'diff --git' line
            awk 'BEGIN{p=0} /^diff --git /{p=1} p{print}' patch.diff > patch.clean || true
            if [ -s patch.clean ]; then mv patch.clean patch.diff; fi

            # Basic diff shape sanity (more tolerant)
            grep -qE '^diff --git a/.+ b/.+' patch.diff || { 
              echo "Malformed diff header"; 
              echo "First 20 lines for debug:"; sed -n '1,20p' patch.diff; 
              exit 78; 
            }

            # Ensure targets exist or are new (paired with /dev/null)
            while IFS= read -r line; do
              p="${line#+++ b/}"; [ -z "$p" ] && continue
              if ! git ls-files --error-unmatch "$p" >/dev/null 2>&1; then
                grep -qE "^--- a/$p$|^--- /dev/null$" patch.diff || {
                  echo "Path not in repo and not marked new: $p"; exit 78; }
              fi
            done < <(grep -E '^\+\+\+ b/' patch.diff)

            # Apply (normal -> 3way -> GNU patch fuzz)
            if git apply --index --whitespace=fix patch.diff; then
              echo "Applied with git apply (normal)."
            elif git apply --index --3way --whitespace=fix patch.diff; then
              echo "Applied with git apply (--3way)."
            else
              echo "git apply failed; trying GNU patch with fuzz."
              sudo apt-get update -y && sudo apt-get install -y patch || true
              if patch -p0 --fuzz=3 -i patch.diff; then
                git add -A
              else
                echo "Patch still failed. Showing rejects:"
                find . -name "*.rej" -maxdepth 5 -print -exec tail -n +1 {} \; || true
                exit 1
              fi
            fi

            # Stage only real source files; drop temp AI artifacts
            git add -A
            git reset artifacts/ patch.diff prompt.txt gen_patch.py -- || true
            git checkout -- artifacts/ patch.diff prompt.txt gen_patch.py 2>/dev/null || true
            rm -f patch.diff prompt.txt gen_patch.py || true
            rm -rf artifacts || true

            CHANGED=$(git status --porcelain | wc -l)
            echo "changed_files=$CHANGED" >> "$GITHUB_OUTPUT"
          

        - name: Create autofix PR
          if: ${{ steps.apply.outputs.changed_files != '0' }}
          uses: peter-evans/create-pull-request@v6
          with:
            token: ${{ secrets.GH_TOKEN }}
            branch: autofix/${{ github.run_id }}
            base: main
            title: "Autofix: CI failure remediation (run #${{ github.run_number }})"
            commit-message: "Autofix: apply AI-generated patch"
            body: |
              Auto-created after CI failure.
              Model: openai/gpt-4o (actions/ai-inference@v1)
              Temporary prompt/patch/artifacts were excluded.
            labels: autofix, ci
            signoff: true




        


     
