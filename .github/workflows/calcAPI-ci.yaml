name: calcAPI-ci.yaml

on:
  push:
    branches: [ "main" ]
    paths:
      - '**/*.go'
      - go.mod
      - go.sum
      - '.github/workflows/**'
  pull_request:
    branches: [ "main" ]
    paths:
      - '**/*.go'
      - go.mod
      - go.sum
      - '.github/workflows/**'

jobs:
  build:
    runs-on: ubuntu-latest
    env:
      SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
      NOTIFY: .github/workflows/notify.sh
      IMAGE: m4gapower/calcapi   # must be lowercase for Docker
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24.6'
          cache: true

      - name: Notify Start
        shell: bash
        run: |
          chmod +x "$NOTIFY"
          echo v1.63.4 > .golangci.version
          mkdir -p artifacts
          "$NOTIFY" ":bell: Starting ${{ github.event.repository.name }} CI - Run (#$GITHUB_RUN_NUMBER) Commit: ${{ github.event.head_commit.message }} :bell:" "$SLACK_WEBHOOK"

      - name: Cache golangci-lint binary
        id: lintcache
        uses: actions/cache@v4
        with:
          path: ~/go/bin/golangci-lint
          key: ${{ runner.os }}-golangci-${{ hashFiles('.golangci.version') }}

      - name: Install dependencies
        shell: bash
        run: |
          sudo apt-get update -y && sudo apt-get install -y jq
          go mod tidy
          go mod download
          if [ "${{ steps.lintcache.outputs.cache-hit }}" != "true" ]; then
            GOLANGCI_VERSION=$(cat .golangci.version || echo v1.63.4)
            go install github.com/golangci/golangci-lint/cmd/golangci-lint@${GOLANGCI_VERSION}
          fi

      - name: Run golangci-lint
        shell: bash
        run: |
          set +e
          "$NOTIFY" "Starting Step - Lint" "$SLACK_WEBHOOK"
          mkdir -p artifacts
          golangci-lint run 2>&1 | tee artifacts/lint.log
          STATUS=${PIPESTATUS[0]}
          OUTPUT=$(sed 's/"/\\"/g' artifacts/lint.log | sed ':a;N;$!ba;s/\n/\\n/g')
          if [ $STATUS -eq 0 ]; then
            "$NOTIFY" "Step - Lint ‚úÖ Success" "$SLACK_WEBHOOK"
          else
            "$NOTIFY" "Step - Lint ‚ùå Failed:\n\`\`\`$OUTPUT\`\`\`" "$SLACK_WEBHOOK"
            exit 1
          fi

      - name: Early Build
        shell: bash
        run: |
          set +e
          "$NOTIFY" "Starting Step - Early Build" "$SLACK_WEBHOOK"
          mkdir -p artifacts
          go build -v ./... 2>&1 | tee artifacts/build.log
          STATUS=${PIPESTATUS[0]}
          OUTPUT=$(cat artifacts/build.log)
          if [ $STATUS -eq 0 ]; then
            "$NOTIFY" "Step - Early Build ‚úÖ Success" "$SLACK_WEBHOOK"
          else
            "$NOTIFY" "Step - Early Build ‚ùå Failed\n\`\`\`$OUTPUT\`\`\`" "$SLACK_WEBHOOK"
            exit 1
          fi

      - name: Test
        shell: bash
        run: |
          set +e
          "$NOTIFY" "Starting Step - Test" "$SLACK_WEBHOOK"
          mkdir -p artifacts
          go test -v ./... 2>&1 | tee artifacts/test.log
          STATUS=${PIPESTATUS[0]}
          OUTPUT=$(sed 's/"/\\"/g' artifacts/test.log | sed ':a;N;$!ba;s/\n/\\n/g')
          if [ $STATUS -eq 0 ]; then
            "$NOTIFY" "Step - Test ‚úÖ Success" "$SLACK_WEBHOOK"
          else
            "$NOTIFY" "Step - Test ‚ùå Failed:\n\`\`\`$OUTPUT\`\`\`" "$SLACK_WEBHOOK"
            exit 1
          fi

      - name: Build Docker image
        shell: bash
        run: |
          set -o pipefail
          "$NOTIFY" "üê≥ Starting Step - Build Docker image" "$SLACK_WEBHOOK"
          mkdir -p artifacts
          docker build --progress=plain -t "$IMAGE:latest" . 2>&1 | tee artifacts/docker-build.log
          STATUS=${PIPESTATUS[0]}
          if [ $STATUS -eq 0 ]; then
            "$NOTIFY" "Step - Build Docker image ‚úÖ Success" "$SLACK_WEBHOOK"
          else
            "$NOTIFY" "Step - Build Docker image ‚ùå Failed" "$SLACK_WEBHOOK"
            exit 1
          fi

      - name: Run & Test container
        shell: bash
        run: |
          "$NOTIFY" "üß™ Starting Step - Run & Test container" "$SLACK_WEBHOOK"
          docker run -d --rm -p 8080:8080 --name mycalc_test "$IMAGE:latest"
          mkdir -p artifacts
          for i in {1..10}; do
            if curl -fsS --max-time 2 http://localhost:8080/health | jq -e -r '.status=="ok"' >/dev/null; then
              HEALTH_JSON=$(curl -fsS http://localhost:8080/health || echo '{}')
              echo "$HEALTH_JSON" > artifacts/health.json
              SHORT=$(echo "$HEALTH_JSON" | jq -c .)
              "$NOTIFY" "Step - Run & Test container ‚úÖ Success (on :8080)\nHealth: \`\`\`${SHORT}\`\`\`" "$SLACK_WEBHOOK"
              docker stop mycalc_test
              exit 0
            fi
            sleep 1
          done
          curl -fsS http://localhost:8080/health > artifacts/health.json || true
          docker logs mycalc_test > artifacts/container.log 2>&1 || true
          TAIL=$(tail -n 80 artifacts/container.log | sed 's/"/\\"/g' | sed ':a;N;$!ba;s/\n/\\n/g')
          "$NOTIFY" "Step - Run & Test container ‚ùå Failed (no healthy response)\nLast logs:\n\`\`\`${TAIL}\`\`\`" "$SLACK_WEBHOOK"
          docker stop mycalc_test || true
          exit 1

      - name: Compute next SemVer MINOR tag
        shell: bash
        run: |
          "$NOTIFY" "üî¢ Starting Step - Compute next SemVer MINOR tag" "$SLACK_WEBHOOK"
          LATEST_SEMVER=$(
            curl -s "https://hub.docker.com/v2/repositories/$IMAGE/tags/?page_size=100" |
            jq -r '[.results[].name | select(test("^[0-9]+\\.[0-9]+\\.[0-9]+$"))]
                    | sort_by(split(".")|map(tonumber)) | last // empty'
          )
          BASE=${LATEST_SEMVER:-1.0.0}
          IFS='.' read -r MAJOR MINOR PATCH <<< "$BASE"
          NEW_TAG="${MAJOR}.$((MINOR+1)).0"
          echo "new_tag=$NEW_TAG" >> "$GITHUB_ENV"
          "$NOTIFY" "Step - Compute tag ‚úÖ $BASE ‚Üí $NEW_TAG" "$SLACK_WEBHOOK"

      - name: Tag image with NEW_TAG
        shell: bash
        run: |
          "$NOTIFY" "üè∑Ô∏è Starting Step - Tag image as ${IMAGE}:${new_tag}" "$SLACK_WEBHOOK"
          docker tag "$IMAGE:latest" "$IMAGE:${new_tag}"
          "$NOTIFY" "Step - Tag image ‚úÖ ${IMAGE}:${new_tag}" "$SLACK_WEBHOOK"

      - name: Push image(s)
        shell: bash
        run: |
          "$NOTIFY" "üì§ Starting Step - Push image(s)" "$SLACK_WEBHOOK"
          echo "${{ secrets.DOCKERHUB_TOKEN }}" | docker login -u "${{ secrets.DOCKERHUB_USERNAME }}" --password-stdin
          docker push "$IMAGE:latest"
          docker push "$IMAGE:${new_tag}"
          "$NOTIFY" "Step - Push image(s) ‚úÖ $IMAGE:latest & $IMAGE:${new_tag}" "$SLACK_WEBHOOK"

      - name: Show changed files (logs) + notify
        shell: bash
        run: |
          COMPARE="https://github.com/${{ github.repository }}/compare/${{ github.event.before }}...${{ github.sha }}"
          CHANGES="$(git diff --name-status ${{ github.event.before }} ${{ github.sha }})"
          echo "Compare: $COMPARE"
          echo "$CHANGES"
          MSG=$'Changes in this push:\n'"$COMPARE"$'\n\n'"$CHANGES"
          "$NOTIFY" "$MSG" "$SLACK_WEBHOOK"

      - name: Final pipeline result
        if: success()
        shell: bash
        run: |
          "$NOTIFY" "üöÄ Pipeline completed successfully!" "$SLACK_WEBHOOK"

      - name: Save CI logs for autofix
        if: failure()
        uses: actions/cache/save@v4
        with:
          path: artifacts
          key: ci-logs-${{ github.run_id }}

      - name: Final pipeline failure
        if: failure()
        shell: bash
        run: |
          "$NOTIFY" "üî• Pipeline failed!" "$SLACK_WEBHOOK"

  autofix:
    needs: build
    if: ${{ always() && needs.build.result == 'failure' && (github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.pull_request.head.repo.full_name == github.repository)) }}
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    env:
      GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
      GEMINI_MODEL: ${{ vars.GEMINI_MODEL || 'gemini-2.5-flash' }}

    steps:
      - name: Check out source
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install tools
        run: sudo apt-get update -y && sudo apt-get install -y jq perl

      - name: Restore CI logs
        uses: actions/cache/restore@v4
        with:
          path: artifacts
          key: ci-logs-${{ github.run_id }}
          fail-on-cache-miss: true

      - name: Prepare prompt
        shell: bash
        run: |
          {
            echo "You are an expert Go developer and CI engineer."
            echo "Task: Read the CI logs and return a SINGLE git-style unified diff that minimally fixes the issues."
            echo "Hard constraints:"
            echo " - Output EXACTLY what `git diff` would emit."
            echo " - Include 'diff --git a/<path> b/<path>', 'index', '---', '+++', and '@@' hunks."
            echo " - Hunk counts MUST match. No prose, no backticks, no nested code fences."
            echo " - Only modify files in this repo."
            echo " - Ensure /health returns {\"status\":\"ok\"}."
            echo " - Use: defer func(){ _ = zl.Sync() }() for zap."
            echo
            echo "=== LINT ===";  cat artifacts/lint.log  2>/dev/null || true;  echo
            echo "=== BUILD ==="; cat artifacts/build.log 2>/dev/null || true;  echo
            echo "=== TEST ===";  cat artifacts/test.log  2>/dev/null || true;  echo
            echo "=== DOCKER BUILD ==="; cat artifacts/docker-build.log 2>/dev/null || true; echo
            echo "=== HEALTH ==="; sed -e 's/^/HEALTH: /' artifacts/health.json 2>/dev/null || true
          } > prompt.txt
          wc -c prompt.txt || true

      - name: Call Gemini for patch
        id: gen
        shell: bash
        env:
          LANG: C.UTF-8
        run: |
          if [ -z "$GEMINI_API_KEY" ]; then
            echo "GEMINI_API_KEY not set; skipping autofix."; exit 0
          fi
          KEY=$(printf "%s" "$GEMINI_API_KEY" | tr -d '\r\n ')
          MODEL=$(printf "%s" "$GEMINI_MODEL" | tr -d '\r\n ')
          BODY=$(jq -Rs '{contents:[{role:"user",parts:[{text:.}]}]}' < prompt.txt)

          curl -sS "https://generativelanguage.googleapis.com/v1beta/models/${MODEL}:generateContent" \
            -H "Content-Type: application/json" \
            -H "x-goog-api-key: ${KEY}" \
            -d "$BODY" > gemini_resp.json

          jq -r '[.candidates[]?.content.parts[]?.text // empty] | join("\n")' gemini_resp.json > ai_text.txt

          # Initial naive extraction (acts as presence check)
          awk '/^```(diff|patch)/{f=1;next} /^```/{if(f){f=0;next}} f' ai_text.txt > changes.patch || true
          if [ -s changes.patch ]; then
            echo "patch_present=true" >> "$GITHUB_OUTPUT"
          else
            echo "No patch extracted."; echo "patch_present=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Extract & Sanitize Patch
        id: sanitize
        if: steps.gen.outputs.patch_present == 'true'
        shell: bash
        run: |
          # Normalize newlines + strip fences
          sed -i 's/\r$//' ai_text.txt
          perl -0777 -ne 'print $1 if /```(?:diff|patch)\s*\n([\s\S]*?)\n```/s' ai_text.txt > changes.patch || true
          # Fallback: model sometimes omits fences
          [ -s changes.patch ] || cp ai_text.txt changes.patch

          # Remove UTF-8 BOM if present
          printf '%s' "$(tail -c +1 changes.patch)" > changes.patch

          # Require git-style header
          head -n1 changes.patch | grep -Eq '^diff --git ' || : > changes.patch

          if [ -s changes.patch ]; then
            echo "sanitized_patch=true" >> "$GITHUB_OUTPUT"
            echo "---- PATCH HEAD (first 120 lines) ----"
            nl -ba changes.patch | sed -n '1,120p'
            echo "--------------------------------------"
          else
            echo "sanitized_patch=false" >> "$GITHUB_OUTPUT"
            echo "Patch empty after sanitization."
          fi

      - name: Patch Doctor (auto-fix common format issues)
        id: doctor
        if: steps.sanitize.outputs.sanitized_patch == 'true'
        shell: bash
        run: |
          set -e
          cp changes.patch changes.orig.patch

          # 1) Drop invalid 'index' lines (non-hex blob IDs)
          perl -0777 -pe 's/^index (?![0-9a-f]{7,40}\.\.[0-9a-f]{7,40}\s+\d+).*?\n//mg' changes.patch > _t && mv _t changes.patch

          # 2) Ensure each hunk body line starts with ' ' or '+' or '-' or '\' (for "\ No newline...")
          awk '
            BEGIN{inh=0}
            /^diff --git / {inh=0; print; next}
            /^index / || /^--- / || /^\+\+\+ / {print; next}
            /^@@ .* @@/ {inh=1; print; next}
            {
              if (inh) {
                if ($0 ~ /^[ \+\-\\]/) print; else print " " $0
              } else {
                print
              }
            }
          ' changes.patch > _t && mv _t changes.patch

          # 3) Ensure file ends with newline
          tail -c1 changes.patch | od -An -t x1 | grep -q '0a' || echo >> changes.patch

          echo "---- Around suspect area (60-80) ----"
          nl -ba changes.patch | sed -n '60,80p'
          echo "-------------------------------------"

      - name: Validate Patch
        id: validate
        if: steps.doctor.conclusion == 'success'
        shell: bash
        run: |
          set -e
          if git apply --check --verbose -p1 changes.patch; then
            echo "strip=p1" >> "$GITHUB_OUTPUT"
          elif git apply --check --verbose changes.patch; then
            echo "strip=none" >> "$GITHUB_OUTPUT"
          else
            echo "code_changed=false" >> "$GITHUB_OUTPUT"
            echo "Patch failed validation."; exit 0
          fi

      - name: Apply patch & verify
        id: apply
        if: steps.validate.outputs.strip
        shell: bash
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          STRIP="${{ steps.validate.outputs.strip }}"
          if [ "$STRIP" = "p1" ]; then
            git apply --index --3way --whitespace=fix -p1 changes.patch || APPLY_FAIL=1
          else
            git apply --index --3way --whitespace=fix changes.patch || APPLY_FAIL=1
          fi

          if [ "${APPLY_FAIL:-0}" = "1" ]; then
            git reset --hard
            if [ "$STRIP" = "p1" ]; then
              git apply --index --3way --whitespace=fix changes.patch || { echo "code_changed=false" >> "$GITHUB_OUTPUT"; echo "Patch did not apply cleanly."; exit 0; }
            else
              git apply --index --3way --whitespace=fix -p1 changes.patch || { echo "code_changed=false" >> "$GITHUB_OUTPUT"; echo "Patch did not apply cleanly."; exit 0; }
            fi
          fi

          go mod tidy || true
          go build ./... || true
          echo "code_changed=true" >> "$GITHUB_OUTPUT"

      - name: Create Auto-Fix PR
        if: steps.apply.outputs.code_changed == 'true'
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.GH_TOKEN }}
          branch: auto-fix/${{ github.run_id }}
          base: ${{ github.event.pull_request.base.ref || github.event.repository.default_branch }}
          commit-message: "Auto-fix: apply model-suggested changes"
          title: "Auto-fix: CI failures"
          body: |
            PR opened automatically after CI failed.
            Edits generated by Google Gemini model `${{ env.GEMINI_MODEL }}`.
            (Logs were passed between jobs via Actions cache.)
          add-paths: |
            **/*.go
            go.mod
            go.sum
            .golangci.yml
            .github/**/*
          author: "github-actions[bot] <41898282+github-actions[bot]@users.noreply.github.com>"
          committer: "github-actions[bot] <41898282+github-actions[bot]@users.noreply.github.com>"
          labels: |
            ci
            auto-fix
          delete-branch: true

